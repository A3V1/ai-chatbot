import os
import logging
from typing import Dict, List, Tuple, Optional, Any, Union
from dataclasses import dataclass
from enum import Enum
from dotenv import load_dotenv

from langchain.memory import ConversationBufferMemory
from langchain.prompts import PromptTemplate
from langchain_openai import ChatOpenAI
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_pinecone import PineconeVectorStore

from data_processing.user_context import (
    get_user_context, load_user_data, get_user_info, save_user_data,
    update_user_context, set_selected_plan, get_selected_plan
)
from jinja2 import Template
from data_processing.mysql_connector import get_mysql_connection, get_policy_brochure_url

# Configure logging for debugging and error tracking
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ConversationState(Enum):
    """Enum for conversation states in the chat flow."""
    START = 'start'
    RECOMMENDATION_GIVEN = 'recommendation_given'
    SHOWING_DETAILS = 'showing_details'
    DISCUSSING_POLICY = 'discussing_policy'
    AWAITING_APPLICATION_CONFIRMATION = 'awaiting_application_confirmation'
    AWAITING_PAYMENT_CONFIRMATION = 'awaiting_payment_confirmation'
    PAYMENT_INITIATED = 'payment_initiated'


@dataclass
class PaymentResponse:
    """Data class for payment response structure sent to frontend."""
    action: str
    plan: str
    amount: float
    message: str


class ChatBotConfig:
    """Configuration for ChatBot: API keys, model names, and vector DB settings."""
    def __init__(self):
        load_dotenv()
        self.pinecone_env = os.getenv("PINECONE_ENVIRONMENT", "aped-4627-b74a")
        self.openai_api_key = os.getenv("OPENAI_API_KEY")
        self.model_name = "google/gemini-2.5-flash-lite-preview-06-17"  # LLM used for response generation
        self.openai_api_base = "https://openrouter.ai/api/v1"  # OpenRouter API endpoint
        self.temperature = 0.8  # LLM creativity
        self.embedding_model = "all-MiniLM-L6-v2"  # For semantic search
        self.pinecone_index = "insurance-chatbot"  # Pinecone index name
        self.similarity_search_k = 4 # Number of docs to retrieve
        os.environ["PINECONE_ENVIRONMENT"] = self.pinecone_env


class PolicyManager:
    POLICIES = [
        "SmartGrowth ULIP", "InvestSmart ULIP Plan", "MediCare Secure Plan",
        "CarePlus Comprehensive", "WellShield Elite", "HealthGuard Basic",
        "FamilyCare Premium", "SecureTerm Plus", "LifeShield Essential",
        "AutoProtect Comprehensive", "FutureWealth Builder", "HomeSecure Essentials",
        "TotalHome Protection Plan", "AcciGuard Secure", "LifeShield Critical Care"
    ]
    
    @classmethod
    def extract_policy_from_text(cls, text: str) -> Optional[str]:
        """Return the policy name if found in the given text."""
        text_lower = text.lower()
        for policy in cls.POLICIES:
            if policy.lower() in text_lower:
                return policy
        return None


class UserInputProcessor:
    """Processes and categorizes user input for intent detection (affirmative, negative, etc.)."""
    
    YES_VARIANTS = {
        'yes', 'y', 'proceed', 'ok', 'okay', 'sure', 'let\'s go',
        'go ahead', 'continue', 'confirm', 'pay', 'payment', 'ready',
        'show details', 'see details', 'yes please', 'yes, proceed',
        'yes, go ahead', 'yes, pay', 'pay now', 'make payment', 'secure this',
        'let\'s do it', 'i agree', 'i want this', 'book now', 'buy now', 'purchase',
        'yes, i want this', 'yes, i want to pay', 'yes, i want to proceed',
    }
    
    NO_VARIANTS = {'no', 'n'}
    
    APPLICATION_KEYWORDS = {
        'apply', 'i want to apply', 'proceed', 'proceed to application'
    }
    
    PAYMENT_KEYWORDS = {
        'i want to pay', 'payment', 'pay', 'proceed to payment',
        'do payment'
    }
    
    BROCHURE_KEYWORDS = {'brochure', 'details'}
    
    QUESTION_KEYWORDS = {
        'claim', 'exclusion', 'benefit', 'hospital', 'coverage',
        'premium', 'what', 'how', 'when', 'where', 'why'
    }
    
    @classmethod
    def normalize_input(cls, user_input: str) -> str:
        """Lowercase and strip user input for comparison."""
        return user_input.strip().lower()
    
    @classmethod
    def is_affirmative(cls, user_input: str) -> bool:
        """Return True if input is an affirmative response."""
        return cls.normalize_input(user_input) in cls.YES_VARIANTS
    
    @classmethod
    def is_negative(cls, user_input: str) -> bool:
        """Return True if input is a negative response."""
        return cls.normalize_input(user_input) in cls.NO_VARIANTS
    
    @classmethod
    def contains_keywords(cls, user_input: str, keywords: set) -> bool:
        """Return True if any keyword is present in the input."""
        normalized_input = cls.normalize_input(user_input)
        return any(keyword in normalized_input for keyword in keywords)


class PromptTemplate:
    
    RAW_TEMPLATE = """

You are an expert insurance advisor with a proven track record of helping customers find the perfect insurance coverage. Your mission is to guide users through a structured sales process: Recommendation → Details → Application → Payment.

=== CONTEXT & DATA ===
Retrieved Insurance Information: {{ retrieved_context }}

Current Conversation State: {{ conversation_state }}

User Profile:
• Phone: {{ phone_number }}
• Age: {{ age }} years | Annual Budget: ₹{{ premium_budget }}
• Desired Coverage: ₹{{ desired_coverage }}
• Policy Interest: {{ interested_policy_type or 'General Insurance' }}
• Dependents: {{ has_dependents }} | Experience: {{ insurance_experience_level }}
• Payment Mode: {{ premium_payment_mode or 'Annual' }}

Previous Conversation: {{ chat_history }}

Current User Query: {{ question }}

=== RESPONSE GUIDELINES ===

**TONE & STYLE:**
- Professional yet friendly and conversational
- Confident and knowledgeable
- Solution-oriented with urgency
- Keep responses under 50 words unless providing detailed policy information
- Use bullet points for policy features, paragraphs for conversation

**CORE OBJECTIVE:** Every response must move the conversation toward policy purchase and payment completion.

=== STATE-BASED RESPONSE STRATEGY ===

**STATE: 'start'**
GOAL: Analyze user profile and recommend the most suitable policy immediately.

Response Format:
"Based on your profile ({{ age }} years, ₹{{ desired_coverage }} coverage, ₹{{ premium_budget }} budget), I recommend **[Policy Name]**.

Key highlights:
• Coverage: ₹[amount]
• Premium: ₹[amount]/year
• [Top 2-3 benefits relevant to user]

This perfectly matches your requirements. Would you like to see the complete details and proceed with the application?"

Policy Selection Logic:
- Match user's interested_policy_type with available policies
- Consider age, budget, and coverage requirements
- If no exact match, recommend the closest suitable policy
- Always explain why this policy suits their specific needs

**STATE: 'recommendation_given'**
GOAL: Provide compelling details and move toward application.

For Policy Details Request:
"**[Policy Name]** offers exceptional value for your profile:

✓ Coverage: ₹{{ desired_coverage }}
✓ Premium: ₹[amount]/{{ premium_payment_mode }}
✓ [Key benefit 1 - specific to user needs]
✓ [Key benefit 2 - competitive advantage]
✓ [Key benefit 3 - peace of mind factor]

Special features for you:
• [Personalized feature based on profile]
• [Claim settlement record/network hospitals if health]
• [Tax benefits if applicable]

Ready to secure this excellent rate? Shall we start your application?"

For Brochure Request:
"Here's the detailed brochure: {{ policy_brochure_url }}

This policy is specifically designed for someone with your profile - {{ age }} years old, looking for ₹{{ desired_coverage }} coverage within ₹{{ premium_budget }} budget. 

Ready to apply and lock in this rate today?"

**STATE: 'showing_details'**
GOAL: Address concerns and close for application.

For Questions about Policy:
- Answer specifically using retrieved_context
- Always relate benefits back to user's personal situation
- End with application close: "This addresses your concern perfectly. Ready to apply?"

For Claims Questions:
"Claims are processed within 24-48 hours with {{ claim_process or '95%+ approval rate' }}. Our network includes {{ hospital_count or 'major' }} hospitals nationwide. This ensures you get hassle-free treatment when needed. Shall we secure this coverage for you today?"

For Exclusions Questions:
"The exclusions are standard: {{ exclusions or 'pre-existing diseases (2-year waiting), cosmetic procedures, and experimental treatments' }}. However, this policy covers all essential medical needs for your family. The benefits far outweigh these standard exclusions. Ready to proceed?"

**STATE: 'awaiting_application_confirmation'**
GOAL: Confirm application and transition to payment.

For Yes/Affirmative:
"Excellent choice! I'm initiating your application for **[Policy Name]** with ₹{{ desired_coverage }} coverage at ₹[premium]/{{ premium_payment_mode }}.

You'll receive confirmation within 2-3 minutes via SMS and email. 

Ready to complete the payment and activate your policy immediately?"

For No/Hesitation:
"I understand you might need more clarity. What specific aspect would you like me to explain further? I'm here to ensure you make the best decision for your family's security."

**STATE: 'awaiting_payment_confirmation'**
GOAL: Complete the sale with payment.

For Yes/Affirmative:
Return PaymentResponse object:
{
  "action": "redirect_to_payment",
  "plan": "[Selected Policy Name]",
  "amount": [Premium Amount],
  "message": "Redirecting to secure payment gateway for [Policy Name] - ₹[amount]. Your policy will be active immediately after payment!"
}

For Hesitation:
"Payment is 100% secure through our encrypted gateway. You can pay via UPI, card, or net banking. Once paid, your policy is active immediately with instant digital certificate. 

Your family's protection shouldn't wait. Ready to complete this in the next 2 minutes?"

**STATE: 'payment_initiated'**
GOAL: Provide assurance and support.

"Your payment is being processed securely. You'll receive policy documents within 5 minutes via email and SMS.

Thank you for choosing us for your family's protection! Is there anything else I can help you with today?"

=== RESPONSE ENHANCEMENT RULES ===

**Always Include:**
1. **Personalization**: Reference user's age, budget, or family situation
2. **Urgency**: "Lock in this rate", "Secure today", "Don't wait"
3. **Social Proof**: "95% customer satisfaction", "Trusted by millions"
4. **Clear Next Step**: Specific call-to-action in every response

**Never Do:**
- Give generic responses without user context
- Provide multiple policy options (creates confusion)
- Use technical jargon without explanation
- End responses without a clear call-to-action
- Repeat the same information unnecessarily

**Objection Handling:**
- "I need to think about it" → "I understand this is important. What specific aspect would help you decide today? I can address any concerns right now."
- "It's expensive" → "Let's break this down: ₹[amount] per month secures ₹{{ desired_coverage }} for your family. That's less than [relatable daily expense]. Can you put a price on your family's security?"
- "I'll compare with others" → "I've already analyzed the market for your specific needs. This offers the best value with [specific advantage]. Let's secure this rate before it changes."

=== QUALITY CONTROL ===

Before responding, ensure:
✓ Response directly addresses the user's current state and query
✓ Includes personalized elements from user profile
✓ Has a clear, compelling call-to-action
✓ Maintains sales momentum toward payment
✓ Uses appropriate tone for the conversation stage
✓ Stays within word limit unless providing detailed policy info

Remember: Your goal is not just to inform, but to guide the user to a purchase decision with confidence and urgency while maintaining trust and professionalism.
"""


class ChatBot:
    def __init__(self, phone_number: str, initial_context: Optional[Dict[str, Any]] = None, initial_chat_history: Optional[List[Dict[str, Any]]] = None):
        self.phone_number = phone_number
        self.config = ChatBotConfig()
        self._initialize_components()
        if initial_context is not None and initial_chat_history is not None:
            self.user_context = initial_context
            self.user_info = get_user_info(self.phone_number) or {} # Always load latest user_info
            for msg in initial_chat_history:
                if msg.get("type") == "human":
                    self.memory.chat_memory.add_user_message(msg["content"])
                elif msg.get("type") == "ai":
                    self.memory.chat_memory.add_ai_message(msg["content"])
            logger.info(f"ChatBot initialized with provided context for phone: {self.phone_number}")
        else:
            self._load_user_data()        

    def _initialize_components(self) -> None:
        """Initialize LLM, vector store, retriever, and memory buffer."""
        try:
            self.llm = ChatOpenAI(
                model=self.config.model_name,
                openai_api_key=self.config.openai_api_key,
                openai_api_base=self.config.openai_api_base,
                temperature=self.config.temperature
            )
            
            embedding = HuggingFaceEmbeddings(model_name=self.config.embedding_model)
            
            self.vectorstore = PineconeVectorStore.from_existing_index(
                index_name=self.config.pinecone_index,
                embedding=embedding
            )
            
            self.retriever = self.vectorstore.as_retriever()
            self.memory = ConversationBufferMemory(
                memory_key="chat_history",
                return_messages=True
            )
            # Enable ConversationalRetrievalChain with ConversationBufferMemory
            from langchain.chains import ConversationalRetrievalChain
            from langchain.prompts import PromptTemplate as LC_PromptTemplate
            prompt = LC_PromptTemplate(template=PromptTemplate.RAW_TEMPLATE, input_variables=[...])
            self.chain = ConversationalRetrievalChain.from_llm(
                llm=self.llm,
                retriever=self.retriever,
                memory=self.memory,
                combine_docs_chain_kwargs={"prompt": prompt}
            )
            logger.info("ChatBot components initialized successfully")
            
        except Exception as e:
            logger.error(f"Error initializing ChatBot components: {e}")
            raise
    
    def add_user_plus_bot(self, user_message: str, bot_message: str) -> None:
        """
        Add both user and bot messages to the chat history in one call.
        """
        self.memory.chat_memory.add_user_message(user_message)
        self.memory.chat_memory.add_ai_message(bot_message)

    def _load_user_data(self) -> None:
        """Load user context and chat history from DB, and populate memory."""
        try:
            context, chat_history = load_user_data(self.phone_number)
            self.user_context = context or {}
            
            # Load chat history into memory
            chat_history = chat_history or []
            for msg in chat_history:
                if msg.get("type") == "human":
                    self.memory.chat_memory.add_user_message(msg["content"])
                elif msg.get("type") == "ai":
                    self.memory.chat_memory.add_ai_message(msg["content"])
            
            self.user_info = get_user_info(self.phone_number) or {}
            logger.info(f"User data loaded for phone: {self.phone_number}")
            
        except Exception as e:
            logger.error(f"Error loading user data: {e}")
            self.user_context = {}
            self.user_info = {}
    
    def get_conversation_state(self) -> ConversationState:
        """Fetch the current conversation state from DB (default: START)."""
        user_context = get_user_context(self.phone_number) or {}
        state_str = user_context.get('conversation_state', ConversationState.START.value)
        
        try:
            return ConversationState(state_str)
        except ValueError:
            logger.warning(f"Invalid conversation state: {state_str}. Defaulting to START")
            return ConversationState.START
    
    def set_conversation_state(self, state: ConversationState) -> None:
        """Set and persist the conversation state, and update in-memory context."""
        try:
            update_user_context(self.phone_number, {'conversation_state': state.value})
            self.user_context["conversation_state"] = state.value
            logger.debug(f"Conversation state updated to: {state.value}")
            self._save_context()
        except Exception as e:
            logger.error(f"Error updating conversation state: {e}")
    
    def _save_context(self):
        """Persist conversation state, summary, and chat history to DB after each message."""
        # Update context summary with last bot message (or a simple summary)
        last_bot_msg = None
        for msg in reversed(self.memory.chat_memory.messages):
            if msg.type == "ai":
                last_bot_msg = msg.content
                break
        context_summary = last_bot_msg or self.user_context.get("context_summary", "")
        # Save to DB
        save_user_data(
            self.phone_number,
            context_summary,
            [
                {"type": m.type, "content": m.content}
                for m in self.memory.chat_memory.messages
            ]
        )
        # Update in-memory context
        self.user_context["context_summary"] = context_summary
        self.user_context["conversation_state"] = self.get_conversation_state().value
        
    def _handle_payment_confirmation(self, query: str) -> Union[PaymentResponse, str]:
        """Handle user input when awaiting payment confirmation."""
        if UserInputProcessor.is_affirmative(query):
            self.set_conversation_state(ConversationState.PAYMENT_INITIATED)
            plan = get_selected_plan(self.phone_number)
            amount = self.user_info.get('premium_budget', 1000)
            response = PaymentResponse(
                action='redirect_to_payment',
                plan=plan,
                amount=float(amount),
                message='Redirecting to payment page...'
            )
            self.add_user_plus_bot(query, response.message)
            return response
        elif UserInputProcessor.is_negative(query):
            self.set_conversation_state(ConversationState.SHOWING_DETAILS)
            response = 'No problem! Feel free to ask any questions about the policy.'
            self.add_user_plus_bot(query, response)
            return response
        return self._generate_llm_response(query)
    
    def _handle_payment_initiated(self, query: str) -> Union[PaymentResponse, str]:
        """Handle payment initiated state."""
        if UserInputProcessor.contains_keywords(query, UserInputProcessor.PAYMENT_KEYWORDS):
            plan = get_selected_plan(self.phone_number)
            amount = self.user_info.get('premium_budget', 1000)
            response = PaymentResponse(
                action='redirect_to_payment',
                plan=plan,
                amount=float(amount),
                message='Redirecting to payment page...'
            )
            self.memory.chat_memory.add_ai_message(response.message)
            return response
        
        self.add_user_plus_bot(query, "Your payment is being processed. If you have any more questions or need further assistance, let me know!")
        return "Your payment is being processed. If you have any more questions or need further assistance, let me know!"
    
    def _handle_application_confirmation(self, query: str) -> str:
        """Handle application confirmation state."""
        if UserInputProcessor.is_affirmative(query):
            self.set_conversation_state(ConversationState.AWAITING_PAYMENT_CONFIRMATION)
            # Set selected plan in user_context when user confirms application
            last_policy = self._extract_last_policy_from_history()
            logger.info(f"[Application Confirmation] Phone: {self.phone_number}, Extracted Policy: {last_policy}")
            if last_policy:
                result = set_selected_plan(self.phone_number, last_policy)
                logger.info(f"set_selected_plan result: {result}")
            response = "Perfect! Starting your application now. You'll get confirmation shortly. Ready to make payment?"
            self.add_user_plus_bot(query, response)
            return response
        elif UserInputProcessor.is_negative(query):
            self.set_conversation_state(ConversationState.SHOWING_DETAILS)
            response = 'No worries! Let me know if you have other questions about the policy.'
            self.add_user_plus_bot(query, response)
            return response
        return self._generate_llm_response(query)
    
    def _handle_recommendation_given(self, query: str) -> str:
        """Handle user input after a policy recommendation has been given."""
        if UserInputProcessor.is_affirmative(query):
            self.set_conversation_state(ConversationState.SHOWING_DETAILS)
            last_policy = self._extract_last_policy_from_history()
            logger.info(f"[Recommendation Given] Phone: {self.phone_number}, Extracted Policy: {last_policy}")
            if last_policy:
                result = set_selected_plan(self.phone_number, last_policy)
                logger.info(f"set_selected_plan result: {result}")
                brochure_url = get_policy_brochure_url(last_policy)
                if brochure_url:
                    response = f"Here's the {last_policy} brochure: {brochure_url}\n\nThis plan is perfect for your profile. Ready to apply and lock in this rate?"
                else:
                    response = f"{last_policy} offers:\n✓ ₹10L coverage\n✓ Cashless hospitals\n✓ No waiting period for accidents\n✓ Family floater option\n\nReady to apply?"
            else:
                response = "Details not available. Please ask about other policies or provide more details."
            self.memory.chat_memory.add_ai_message(response)
            self.memory.chat_memory.add_user_message(query)
            # Use add_user_plus_bot for consistency
            # self.add_user_plus_bot(query, response)
            return response
        elif UserInputProcessor.contains_keywords(query, UserInputProcessor.BROCHURE_KEYWORDS):
            # If user asks for details/brochure, handle it directly
            return self._handle_brochure_request(query)
        return self._generate_llm_response(query)
    
    def _handle_brochure_request(self, query: str) -> str:
        """Handle user requests for a policy brochure."""
        self.set_conversation_state(ConversationState.SHOWING_DETAILS)
        last_policy = self._extract_last_policy_from_history()
        if last_policy:
            brochure_url = get_policy_brochure_url(last_policy)
            if brochure_url:
                response = f"Here's the {last_policy} brochure: {brochure_url}\n\nReady to apply?"
            else:
                response = f"{last_policy} details:\n✓ Comprehensive coverage\n✓ Cashless claims\n✓ Wide network\n\nReady to apply?"
        else:
            response = "I'll get you the policy details. Ready to apply after reviewing?"
        self.add_user_plus_bot(query, response)
        return response
    
    def _handle_application_request(self, query: str) -> str:
        """Handle user requests to apply for a policy."""
        self.set_conversation_state(ConversationState.AWAITING_APPLICATION_CONFIRMATION)
        response = "Excellent choice! I can start your application right now. Shall we proceed with your details?"
        self.add_user_plus_bot(query, response)
        return response
    
    def _handle_payment_request(self, query: str) -> str:
        """Handle user requests to proceed to payment."""
        self.set_conversation_state(ConversationState.AWAITING_PAYMENT_CONFIRMATION)
        response = "Ready to secure your policy!"
        self.add_user_plus_bot(query, response)
        return response
    
    def _generate_llm_response(self, query: str) -> str:
        """
        Generate a response using the LLM.
        - Performs semantic search for relevant docs
        - Builds a prompt with user profile, context, and chat history
        - Invokes the LLM and returns its response
        """
        try:
            # Enhance query with interested_policy_type for better semantic search
            interested_policy_type = self.user_info.get('interested_policy_type') or self.user_context.get('interested_policy_type')
            search_query = query
            if interested_policy_type and "recommend" in query.lower():
                search_query = f"{interested_policy_type} insurance policy recommendation {query}"
            elif interested_policy_type:
                search_query = f"{interested_policy_type} insurance {query}"

            retrieved_docs = self.vectorstore.similarity_search(
                search_query, k=self.config.similarity_search_k
            )
            retrieved_context = "\n---\n".join([doc.page_content for doc in retrieved_docs])
            
            chat_history_str = ""
            for msg in self.memory.chat_memory.messages:
                if msg.type == "human":
                    chat_history_str += f"User: {msg.content}\n"
                elif msg.type == "ai":
                    chat_history_str += f"Bot: {msg.content}\n"
            
            merged_context = {
                **self.user_context,
                **self.user_info,
                "retrieved_context": retrieved_context,
                "chat_history": chat_history_str,
                "question": query,
                "conversation_state": self.get_conversation_state().value,
            }
            
            full_prompt = Template(PromptTemplate.RAW_TEMPLATE).render(merged_context)
            response = self.llm.invoke(full_prompt)
            self.add_user_plus_bot(query, response.content)
            # --- Set selected_plan as soon as a valid policy is mentioned in the AI response ---
            last_policy = self._extract_last_policy_from_history()
            if last_policy:
                logger.info(f"[LLM Response] Phone: {self.phone_number}, Extracted Policy: {last_policy}")
                result = set_selected_plan(self.phone_number, last_policy)
                logger.info(f"set_selected_plan result: {result}")
            return response.content
        except Exception as e:
            logger.error(f"Error generating LLM response: {e}")
            return "I apologize, but I'm having trouble processing your request. Please try again."
    
    def _extract_last_policy_from_history(self) -> Optional[str]:
        """Extract the latest policy name from chat history that matches POLICIES, cleaning formatting."""
        import re
        policies = PolicyManager.POLICIES
        for msg in reversed(self.memory.chat_memory.messages):
            # Remove markdown/bold/asterisks and extra spaces
            content_clean = re.sub(r'[\*`_]', '', msg.content).strip().lower()
            for policy in policies:
                if policy.lower() in content_clean:
                    logger.debug(f"Matched policy '{policy}' in message: {msg.content}")
                    return policy
        # Fallback: check user_context
        policy = self.user_context.get('selected_plan')
        if policy:
            logger.debug(f"Fallback to user_context selected_plan: {policy}")
            return policy
        logger.debug("No policy found in chat history or user_context.")
        return None
    
    # --- Conversational Retrieval Chain: Direct LLM Q&A (for simple use cases) ---
    def ask_chain(self, query: str):
        """
        Basic ask method using ConversationalRetrievalChain.
        Returns the chain's response to the user's query.
        Use this for simple Q&A without stateful business logic.
        """
        return self.chain.invoke({"question": query})

    # --- Main Chat Entry Point: State-Aware, Business Logic Routing ---
    def ask(self, query: str) -> Union[str, PaymentResponse]:
        """
        Main entry point for user queries.
        - Routes input based on conversation state and intent
        - Persists context after every message
        - Returns either a string (bot reply) or PaymentResponse
        Use this for production chatbots with stateful flows.
        """
        if not query.strip():
            return "Please provide a valid question or request."
        
        state = self.get_conversation_state()
        logger.debug(f"Processing query in state: {state.value}")
        
        try:
            # State-based routing
            if state == ConversationState.AWAITING_PAYMENT_CONFIRMATION:
                result = self._handle_payment_confirmation(query)
            elif state == ConversationState.PAYMENT_INITIATED:
                result = self._handle_payment_initiated(query)
            elif state == ConversationState.AWAITING_APPLICATION_CONFIRMATION:
                result = self._handle_application_confirmation(query)
            elif state == ConversationState.RECOMMENDATION_GIVEN:
                result = self._handle_recommendation_given(query)
            elif (state == ConversationState.SHOWING_DETAILS and UserInputProcessor.contains_keywords(query, UserInputProcessor.QUESTION_KEYWORDS)):
                result = self._generate_llm_response(query)
            elif UserInputProcessor.contains_keywords(query, UserInputProcessor.APPLICATION_KEYWORDS):
                result = self._handle_application_request(query)
            elif UserInputProcessor.contains_keywords(query, UserInputProcessor.PAYMENT_KEYWORDS):
                result = self._handle_payment_request(query)
            elif UserInputProcessor.contains_keywords(query, UserInputProcessor.BROCHURE_KEYWORDS):
                result = self._handle_brochure_request(query)
            elif state == ConversationState.START:
                self.set_conversation_state(ConversationState.RECOMMENDATION_GIVEN)
                result = self._generate_llm_response(query)
            else:
                response = "I'm here to help with your insurance needs. Ready to apply or have specific questions?"
                self.memory.chat_memory.add_user_message(query)
                self.memory.chat_memory.add_ai_message(response)
                result = response
        except Exception as e:
            logger.error(f"Error processing query: {e}")
            result = "I'm here to help you secure your insurance. You can ask about policy details, say 'yes' to proceed, or type 'pay' to move to payment."
        # Persist context after every message
        self._save_context()
        return result



class UserInfoManager:
    """
    Manages user profile data in the user_info table:
    - Checks for missing fields
    - Updates user info
    - Creates new user entries
    """
    REQUIRED_FIELDS = [
        ("age", "What's your age?"),
        ("desired_coverage", "What is the coverage amount you are looking for?"),
        ("premium_budget", "What is your budget for annual premium?"),
        ("premium_payment_mode", "How would you prefer to pay premiums (Annually, Semi-Annually, Monthly)?"),
        ("preferred_add_ons", "Are there any benefits you want (like accidental death cover, waiver of premium, etc.)?"),
        ("has_dependents", "Do you have any dependents (e.g., spouse, children, parents)? (yes/no)"),
        ("policy_duration_years", "How long would you like the policy coverage to last (in years)?"),
        ("insurance_experience_level", "Have you purchased insurance before?"),
    ]
    
    @classmethod
    def get_missing_fields(cls, user_info: Dict[str, Any]) -> List[Tuple[str, str]]:
        """Get missing user information fields"""
        return [
            (field, question) for field, question in cls.REQUIRED_FIELDS
            if user_info.get(field) in [None, "", "null"]
        ]
    
    @classmethod
    def update_user_info(cls, phone_number: str, field: str, value: str) -> bool:
        """Update user information in database. Only allow fields in REQUIRED_FIELDS."""
        allowed_fields = {f for f, _ in cls.REQUIRED_FIELDS}
        if field not in allowed_fields:
            logger.error(f"Attempted to update disallowed field: {field}")
            return False
        try:
            conn = get_mysql_connection()
            cursor = conn.cursor()
            cursor.execute(
                f"UPDATE user_info SET {field} = %s WHERE phone_number = %s",
                (value, phone_number)
            )
            conn.commit()
            cursor.close()
            conn.close()
            logger.info(f"Updated {field} for user {phone_number}")
            return True
        except Exception as e:
            logger.error(f"Error updating user info: {e}")
            return False
    
    @classmethod
    def create_user(cls, phone_number: str) -> bool:
        """Create a new user entry"""
        try:
            conn = get_mysql_connection()
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO user_info (phone_number) VALUES (%s)",
                (phone_number,)
            )
            conn.commit()
            cursor.close()
            conn.close()
            logger.info(f"Created new user: {phone_number}")
            return True
        except Exception as e:
            logger.error(f"Error creating user: {e}")
            return False


# For FastAPI, expose the correct helpers from the class

def get_missing_user_info_fields(user_info: dict) -> list:
    """
    Returns a list of (field, question) tuples for missing user info fields.
    """
    from cbot import UserInfoManager
    return UserInfoManager.get_missing_fields(user_info)


def update_user_info(phone_number: str, field: str, value: str) -> bool:
    from cbot import UserInfoManager
    return UserInfoManager.update_user_info(phone_number, field, value)


def ask_policy_specific_questions(phone_number, interested_policy_type, chat_history):
    """Return policy-type-specific questions for UI/API. No CLI input."""
    POLICY_TYPE_QUESTIONS = {
        "term life": [
            ("term_duration_years", "For how many years do you want the term life coverage?"),
            ("health_conditions", "Do you have any existing health conditions? (yes/no, specify if yes)"),
            ("smoker_status", "Are you a smoker? (yes/no)")
        ],
        "health": [
            ("pre_existing_diseases", "Do you have any pre-existing diseases? (yes/no, specify if yes)"),
            ("hospital_preference", "Do you have a preferred hospital or hospital network?"),
            ("maternity_need", "Do you need maternity coverage? (yes/no)")
        ],
        "vehicle": [
            ("vehicle_type", "What type of vehicle do you want to insure? (Car/Bike/Other)"),
            ("vehicle_year", "What is the year of manufacture of your vehicle?"),
            ("idv_preference", "Do you have a preferred Insured Declared Value (IDV)? (yes/no, specify if yes)")
        ],
        "investment": [
            ("investment_horizon", "What is your investment horizon (in years)?"),
            ("risk_appetite", "What is your risk appetite? (Low/Medium/High)"),
            ("expected_returns", "What are your expected returns or goals?")
        ],
        "home": [
            ("property_type", "What type of property do you want to insure? (Apartment/House/Other)"),
            ("property_value", "What is the approximate value of your property?"),
            ("natural_disaster_cover", "Do you want natural disaster coverage? (yes/no)")
        ]
    }
    key = (interested_policy_type or '').strip().lower()
    questions = POLICY_TYPE_QUESTIONS.get(key, [])
    # Return as list of dicts for UI/API
    return [{"field": field, "question": question} for field, question in questions]


def extract_policy_type_and_answers(chat_history):
    """
    Extracts the latest 'interested_policy_type' and 'policy_specific_answers' from chat_history.
    Returns a tuple: (interested_policy_type, policy_specific_answers_dict or None)
    """
    interested_policy_type = None
    policy_specific_answers = None
    for msg in chat_history:
        if msg.get("type") == "interested_policy_type":
            interested_policy_type = msg.get("content")
        elif msg.get("type") == "policy_specific_answers":
            policy_specific_answers = msg.get("content")
    return interested_policy_type, policy_specific_answers


# --- API/Frontend integration helpers ---

def get_policy_specific_questions(interested_policy_type: str) -> list:
    """
    Returns a list of dicts: [{"field": ..., "question": ...}] for the given policy type.
    For use by API/UI to fetch questions dynamically.
    """
    POLICY_TYPE_QUESTIONS = {
        "term life": [
            {"field": "term_duration_years", "question": "For how many years do you want the term life coverage?"},
            {"field": "health_conditions", "question": "Do you have any existing health conditions? (yes/no, specify if yes)"},
            {"field": "smoker_status", "question": "Are you a smoker? (yes/no)"}
        ],
        "health": [
            {"field": "pre_existing_diseases", "question": "Do you have any pre-existing diseases? (yes/no, specify if yes)"},
            {"field": "hospital_preference", "question": "Do you have a preferred hospital or hospital network?"},
            {"field": "maternity_need", "question": "Do you need maternity coverage? (yes/no)"}
        ],
        "vehicle": [
            {"field": "vehicle_type", "question": "What type of vehicle do you want to insure? (Car/Bike/Other)"},
            {"field": "vehicle_year", "question": "What is the year of manufacture of your vehicle?"},
            {"field": "idv_preference", "question": "Do you have a preferred Insured Declared Value (IDV)? (yes/no, specify if yes)"}
        ],
        "investment": [
            {"field": "investment_horizon", "question": "What is your investment horizon (in years)?"},
            {"field": "risk_appetite", "question": "What is your risk appetite? (Low/Medium/High)"},
            {"field": "expected_returns", "question": "What are your expected returns or goals?"}
        ],
        "home": [
            {"field": "property_type", "question": "What type of property do you want to insure? (Apartment/House/Other)"},
            {"field": "property_value", "question": "What is the approximate value of your property?"},
            {"field": "natural_disaster_cover", "question": "Do you want natural disaster coverage? (yes/no)"}
        ]
    }
    key = (interested_policy_type or '').strip().lower()
    return POLICY_TYPE_QUESTIONS.get(key, [])


def save_policy_specific_answers(phone_number: str, answers: dict):
    """
    Save policy-specific answers to chat_history for a user (for API/UI use).
    Appends new policy_specific_answers without overwriting old entries.
    """
    context, chat_history = load_user_data(phone_number)
    chat_history = chat_history or []

    # Append new policy-specific answers with timestamp
    chat_history.append({
        "type": "policy_specific_answers",
        "content": answers,
    })

    context_summary = context.get("context_summary") if context else ""
    save_user_data(phone_number, context_summary, chat_history)
    return True



def save_policy_specific_qa(phone_number: str, interested_policy_type: str, answers: dict):
    """
    Append both the questions and user's answers for a specific policy type to chat_history.
    This does NOT remove previous policy_specific_answers entries.
    """
    context, chat_history = load_user_data(phone_number)
    chat_history = chat_history or []

    # Get the actual questions asked
    questions = get_policy_specific_questions(interested_policy_type)
    
    # Convert to full Q&A form
    qa_list = []
    for q in questions:
        field = q.get("field")
        question = q.get("question")
        answer = answers.get(field)
        qa_list.append({"field": field, "question": question, "answer": answer})

    # Append as a new entry in history (do not remove previous ones)
    chat_history.append({
        "type": "policy_specific_answers",
        "qa": qa_list
    })

    context_summary = context.get("context_summary") if context else ""
    save_user_data(phone_number, context_summary, chat_history)
    return True


def get_interested_policy_type(phone_number: str) -> str:
    """
    Returns the interested_policy_type for a user from chat_history, or an empty string if not set.
    """
    _, chat_history = load_user_data(phone_number)
    chat_history = chat_history or []
    for msg in reversed(chat_history):
        if msg.get("type") == "interested_policy_type":
            return msg.get("content")
    return ""


def save_interested_policy_type(phone_number: str, interested_policy_type: str):
    """
    Save interested_policy_type for a user (for API/UI use).
    Save it in chat_history, not in user_info table.
    """
    # Load chat history
    context, chat_history = load_user_data(phone_number)
    chat_history = chat_history or []
    # # Remove old interested_policy_type
    # chat_history = [msg for msg in chat_history if msg.get("type") != "interested_policy_type"]
    chat_history.append({
        "type": "interested_policy_type",
        "content": interested_policy_type
    })
    context_summary = context.get("context_summary") if context else ""
    save_user_data(phone_number, context_summary, chat_history)
    return True


def main():
    """Main function to run the chatbot"""
    print("=== Insurance Chatbot ===")
    
    phone_number = input("Enter your phone number: ").strip()
    if not phone_number:
        print("Phone number is required to start the chat.")
        return
    
    # Check if user exists, create if not
    user_info = get_user_info(phone_number)
    if not user_info:
        print("Creating new user entry...")
        if not UserInfoManager.create_user(phone_number):
            print("Failed to create user. Please try again.")
            return
        user_info = get_user_info(phone_number)
    
    # Collect missing user information
    while True:
        missing_fields = UserInfoManager.get_missing_fields(user_info)
        if not missing_fields:
            break
        for field, question in missing_fields:
            value = input(question + " ").strip()
            if value.lower() in ["exit", "quit"]:
                return
            if not UserInfoManager.update_user_info(phone_number, field, value):
                print(f"Failed to update {field}. Please try again.")
            else:
                continue
        user_info = get_user_info(phone_number)

    # # Ask for interested_policy_type if not present
    # interested_policy_type = user_info.get("interested_policy_type")
    # if not interested_policy_type:
    #     interested_policy_type = input("What type of insurance are you looking for? Health, Term Life, Investment, Vehicle, or Home? ").strip()
    #     if interested_policy_type.lower() in ["exit", "quit"]:
    #         return
    
    interested_policy_type = get_interested_policy_type(phone_number)
    if not interested_policy_type:
        interested_policy_type = input("What type of insurance are you looking for? ").strip()
        if interested_policy_type.lower() in ["exit", "quit"]:
            return
        # Save the interested policy type
        save_interested_policy_type(phone_number, interested_policy_type)

    # Load chat history from DB (or start new)
    context, chat_history = load_user_data(phone_number)
    chat_history = chat_history or []
 
    # Only remove old policy_specific_answers, but keep all other entries (including interested_policy_type)
    # chat_history = [msg for msg in chat_history if msg.get("type") != "policy_specific_answers"]

    # Add policy-specific questions if needed (but do not replace the whole chat_history)
    policy_questions = ask_policy_specific_questions(phone_number, interested_policy_type, [])
    if policy_questions:
        chat_history.extend(policy_questions)

    # Save updated chat_history to DB
    context_summary = context.get("context_summary") if context else ""
    save_user_data(phone_number, context_summary, chat_history)

    # Start chat
    print("\n=== Chat Started ===")
    print("Type 'exit' or 'quit' to end the conversation.\n")
    try:
        bot = ChatBot(phone_number)
        # Immediately recommend a policy after collecting all info
        initial_recommendation = bot.ask("recommend a policy for me")
        if isinstance(initial_recommendation, PaymentResponse):
            print(f"Bot: {initial_recommendation.message}")
            print(f"Action: {initial_recommendation.action}")
            print(f"Plan: {initial_recommendation.plan}")
            print(f"Amount: ₹{initial_recommendation.amount}")
        else:
            print(f"Bot: {initial_recommendation}")
        while True:
            user_input = input("User: ").strip()
            if user_input.lower() in ["exit", "quit"]:
                print("Thank you for using our insurance chatbot!")
                break
            if not user_input:
                continue
            response = bot.ask(user_input)
            if isinstance(response, PaymentResponse):
                print(f"Bot: {response.message}")
                print(f"Action: {response.action}")
                print(f"Plan: {response.plan}")
                print(f"Amount: ₹{response.amount}")
            else:
                print(f"Bot: {response}")
    except KeyboardInterrupt:
        print("\n\nChat interrupted by user.")
    except Exception as e:
        logger.error(f"Error in main chat loop: {e}")
        print("An error occurred. Please restart the application.")


if __name__ == "__main__":
    main()
